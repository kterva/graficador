<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graficador con Ajustes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/1.2.1/chartjs-plugin-zoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .layout {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
        }

        .panel {
            background: #fafafa;
            padding: 20px;
            border-radius: 8px;
        }

        .panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #555;
        }

        .serie-section {
            background: white;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            border: 2px solid #ddd;
        }

        .serie-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .serie-name {
            font-weight: bold;
            color: #333;
        }

        .btn-remove-serie {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-remove-serie:hover {
            background: #c0392b;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        th {
            background: #3498db;
            color: white;
        }

        input[type="number"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .btn {
            padding: 8px 15px;
            margin: 5px 5px 5px 0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .chart-container {
            position: relative;
            height: 600px;
        }

        .equation-display {
            background: #ecf0f1;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .help-btn {
            background: #3498db;
            color: white;
            border: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
            font-size: 14px;
        }

        .help-btn:hover {
            background: #2980b9;
        }

        .help-text {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }

        .color-input {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .controls {
            margin-top: 15px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üìä Graficador de Funciones con Ajustes</h1>

        <div class="layout">
            <div class="panel">
                <h2>Series de Datos</h2>
                <div id="series-container"></div>
                <button class="btn btn-success" onclick="addSerie()">+ Nueva Serie</button>
            </div>

            <div class="panel">
                <h2>Gr√°fica</h2>
                <div class="chart-container">
                    <canvas id="myChart"></canvas>
                </div>
                <div class="controls">
                    <label style="margin-right: 10px;">Etiqueta eje X:</label>
                    <input type="text" id="labelX" value="X" style="width: 150px; padding: 5px; margin-right: 20px;"
                        onchange="updateAxisLabels()">

                    <label style="margin-right: 10px;">Etiqueta eje Y:</label>
                    <input type="text" id="labelY" value="Y" style="width: 150px; padding: 5px;"
                        onchange="updateAxisLabels()">
                </div>
                <div class="controls" style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="resetZoom()">Restablecer Zoom</button>
                    <button class="btn btn-primary" onclick="downloadChart()">Descargar Gr√°fica</button>
                    <button class="btn btn-success" onclick="showIntersection()">Mostrar Intersecci√≥n</button>
                </div>
                <div id="intersection-display"
                    style="display:none; background: #d5f4e6; padding: 15px; margin-top: 15px; border-radius: 5px; border: 2px solid #27ae60;">
                    <h3 style="margin-bottom: 10px; color: #27ae60;">üìç Punto de Intersecci√≥n</h3>
                    <div id="intersection-content"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let series = [];
        let serieCounter = 0;
        let chart = null;

        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];

        const errorBarsPlugin = {
            id: 'errorBars',
            afterDatasetsDraw(chart, args, options) {
                const { ctx } = chart;

                chart.data.datasets.forEach((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    if (!meta.hidden && dataset.errorBars) {
                        ctx.save();
                        ctx.strokeStyle = dataset.borderColor || 'black';
                        ctx.lineWidth = 1;

                        dataset.data.forEach((point, index) => {
                            if (point.xError || point.yError) {
                                const model = meta.data[index];
                                if (!model) return;

                                const x = model.x;
                                const y = model.y;

                                // Draw X error bars
                                if (point.xError) {
                                    const xErrPix = Math.abs(chart.scales.x.getPixelForValue(point.x + point.xError) - chart.scales.x.getPixelForValue(point.x));

                                    ctx.beginPath();
                                    ctx.moveTo(x - xErrPix, y);
                                    ctx.lineTo(x + xErrPix, y);
                                    // Caps
                                    ctx.moveTo(x - xErrPix, y - 3);
                                    ctx.lineTo(x - xErrPix, y + 3);
                                    ctx.moveTo(x + xErrPix, y - 3);
                                    ctx.lineTo(x + xErrPix, y + 3);
                                    ctx.stroke();
                                }

                                // Draw Y error bars
                                if (point.yError) {
                                    const yErrPix = Math.abs(chart.scales.y.getPixelForValue(point.y + point.yError) - chart.scales.y.getPixelForValue(point.y));

                                    ctx.beginPath();
                                    ctx.moveTo(x, y - yErrPix);
                                    ctx.lineTo(x, y + yErrPix);
                                    // Caps
                                    ctx.moveTo(x - 3, y - yErrPix);
                                    ctx.lineTo(x + 3, y - yErrPix);
                                    ctx.moveTo(x - 3, y + yErrPix);
                                    ctx.lineTo(x + 3, y + yErrPix);
                                    ctx.stroke();
                                }
                            }
                        });
                        ctx.restore();
                    }
                });
            }
        };

        Chart.register(errorBarsPlugin);

        function initChart() {
            const ctx = document.getElementById('myChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy',
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'X'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Y'
                            }
                        }
                    }
                }
            });
        }

        function addSerie() {
            const id = serieCounter++;
            const color = colors[id % colors.length];

            const serie = {
                id: id,
                name: `Serie ${id + 1}`,
                color: color,
                data: [{ x: '', y: '', xError: 0, yError: 0 }],
                fitType: 'none',
                equation: '',
                r2: null
            };

            series.push(serie);
            renderSeries();
        }

        function removeSerie(id) {
            series = series.filter(s => s.id !== id);
            renderSeries();
            updateChart();
        }

        function renderSeries() {
            const container = document.getElementById('series-container');
            container.innerHTML = '';

            series.forEach(serie => {
                const div = document.createElement('div');
                div.className = 'serie-section';
                div.innerHTML = `
                    <div class="serie-header">
                        <span class="serie-name">${serie.name}</span>
                        <div>
                            <input type="file" id="file-${serie.id}" style="display:none" accept=".csv" onchange="handleFileSelect(${serie.id}, this)">
                            <button class="btn btn-primary" style="padding: 2px 8px; font-size: 12px;" onclick="importCSV(${serie.id})">Importar CSV</button>
                            <button class="btn btn-primary" style="padding: 2px 8px; font-size: 12px;" onclick="exportCSV(${serie.id})">Exportar CSV</button>
                            <button class="btn btn-danger" style="padding: 2px 8px; font-size: 12px;" onclick="clearTable(${serie.id})">Limpiar</button>
                            <button class="btn-remove-serie" onclick="removeSerie(${serie.id})">Eliminar</button>
                        </div>
                    </div>
                    
                    <label>Color:</label>
                    <input type="color" class="color-input" value="${serie.color}" 
                           onchange="updateSerieColor(${serie.id}, this.value)">
                    
                    <label style="display:block; margin-top:10px;">Tipo de Ajuste:</label>
                    <select onchange="updateFitType(${serie.id}, this.value)">
                        <option value="none">Sin ajuste</option>
                        <option value="linear">Lineal</option>
                        <option value="poly2">Polinomial (grado 2)</option>
                        <option value="poly3">Polinomial (grado 3)</option>
                        <option value="exponential">Exponencial</option>
                        <option value="logarithmic">Logar√≠tmico</option>
                        <option value="power">Potencial</option>
                    </select>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>X</th>
                                <th>¬±X</th>
                                <th>Y</th>
                                <th>¬±Y</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="table-${serie.id}">
                        </tbody>
                    </table>
                    <button class="btn btn-primary" onclick="addRow(${serie.id})">+ Agregar Fila</button>
                    <button class="btn btn-primary" onclick="updateChart()">Graficar</button>
                    
                    <div class="equation-display" id="eq-${serie.id}" style="display:none;"></div>
                `;
                container.appendChild(div);
                renderTable(serie.id);
            });
        }

        function renderTable(serieId) {
            const serie = series.find(s => s.id === serieId);
            const tbody = document.getElementById(`table-${serieId}`);
            tbody.innerHTML = '';

            serie.data.forEach((point, index) => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><input type="number" step="any" value="${point.x}" 
                               data-serie="${serieId}" data-row="${index}" data-col="0"
                               onkeydown="handleKeyDown(event, ${serieId}, ${index}, 0)"
                               onchange="updatePoint(${serieId}, ${index}, 'x', this.value)"></td>
                    <td><input type="number" step="any" value="${point.xError || 0}" 
                               data-serie="${serieId}" data-row="${index}" data-col="1"
                               onkeydown="handleKeyDown(event, ${serieId}, ${index}, 1)"
                               onchange="updatePoint(${serieId}, ${index}, 'xError', this.value)" placeholder="0"></td>
                    <td><input type="number" step="any" value="${point.y}" 
                               data-serie="${serieId}" data-row="${index}" data-col="2"
                               onkeydown="handleKeyDown(event, ${serieId}, ${index}, 2)"
                               onchange="updatePoint(${serieId}, ${index}, 'y', this.value)"></td>
                    <td><input type="number" step="any" value="${point.yError || 0}" 
                               data-serie="${serieId}" data-row="${index}" data-col="3"
                               onkeydown="handleKeyDown(event, ${serieId}, ${index}, 3)"
                               onchange="updatePoint(${serieId}, ${index}, 'yError', this.value)" placeholder="0"></td>
                    <td><button class="btn btn-danger" onclick="removeRow(${serieId}, ${index})">√ó</button></td>
                `;
            });
        }

        function addRow(serieId) {
            const serie = series.find(s => s.id === serieId);
            serie.data.push({ x: '', y: '', xError: 0, yError: 0 });
            renderTable(serieId);
        }

        function removeRow(serieId, index) {
            const serie = series.find(s => s.id === serieId);
            if (serie.data.length > 1) {
                serie.data.splice(index, 1);
                renderTable(serieId);
            }
        }

        function updatePoint(serieId, index, axis, value) {
            const serie = series.find(s => s.id === serieId);
            serie.data[index][axis] = value;
            updateChart(); // Auto-update chart when data changes
        }

        function updateSerieColor(serieId, color) {
            const serie = series.find(s => s.id === serieId);
            serie.color = color;
            updateChart();
        }

        function updateFitType(serieId, fitType) {
            const serie = series.find(s => s.id === serieId);
            serie.fitType = fitType;
            updateChart();
        }

        function exportCSV(serieId) {
            const serie = series.find(s => s.id === serieId);
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "X,Y,xError,yError\n";

            serie.data.forEach(p => {
                if (p.x !== '' && p.y !== '') {
                    csvContent += `${p.x},${p.y},${p.xError || 0},${p.yError || 0}\n`;
                }
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `${serie.name.replace(/\s+/g, '_')}_data.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function importCSV(serieId) {
            document.getElementById(`file-${serieId}`).click();
        }

        function clearTable(serieId) {
            if (confirm('¬øEst√°s seguro de que quieres borrar todos los datos de esta serie?')) {
                const serie = series.find(s => s.id === serieId);
                serie.data = [{ x: '', y: '', xError: 0, yError: 0 }];
                renderTable(serieId);
                updateChart();
            }
        }

        function handleKeyDown(event, serieId, rowIndex, colIndex) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const serie = series.find(s => s.id === serieId);

                // If it's the last row, add a new one
                if (rowIndex === serie.data.length - 1) {
                    addRow(serieId);
                }

                // Focus the cell below
                // We need to wait for renderTable to complete if a row was added
                setTimeout(() => {
                    const nextInput = document.querySelector(`input[data-serie="${serieId}"][data-row="${rowIndex + 1}"][data-col="${colIndex}"]`);
                    if (nextInput) {
                        nextInput.focus();
                        nextInput.select();
                    }
                }, 10);
            } else if (event.key === 'ArrowUp') {
                if (rowIndex > 0) {
                    event.preventDefault();
                    const prevInput = document.querySelector(`input[data-serie="${serieId}"][data-row="${rowIndex - 1}"][data-col="${colIndex}"]`);
                    if (prevInput) {
                        prevInput.focus();
                        prevInput.select();
                    }
                }
            } else if (event.key === 'ArrowDown') {
                const serie = series.find(s => s.id === serieId);
                if (rowIndex < serie.data.length - 1) {
                    event.preventDefault();
                    const nextInput = document.querySelector(`input[data-serie="${serieId}"][data-row="${rowIndex + 1}"][data-col="${colIndex}"]`);
                    if (nextInput) {
                        nextInput.focus();
                        nextInput.select();
                    }
                }
            }
        }

        function handleFileSelect(serieId, input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                const lines = text.split('\n');
                const serie = series.find(s => s.id === serieId);

                // Clear existing data
                serie.data = [];

                lines.forEach((line, index) => {
                    const cleanLine = line.trim();
                    if (!cleanLine) return;

                    // Skip header if it contains letters
                    if (index === 0 && /[a-zA-Z]/.test(cleanLine)) return;

                    const parts = cleanLine.split(',');
                    if (parts.length >= 2) {
                        serie.data.push({
                            x: parseFloat(parts[0]),
                            y: parseFloat(parts[1]),
                            xError: parseFloat(parts[2] || 0),
                            yError: parseFloat(parts[3] || 0)
                        });
                    }
                });

                if (serie.data.length === 0) {
                    serie.data.push({ x: '', y: '', xError: 0, yError: 0 });
                }

                renderTable(serieId);
                updateChart();
                input.value = ''; // Reset input
            };
            reader.readAsText(file);
        }

        function updateChart() {
            const datasets = [];

            series.forEach(serie => {
                const validData = serie.data.filter(p => p.x !== '' && p.y !== '').map(p => ({
                    x: parseFloat(p.x),
                    y: parseFloat(p.y),
                    xError: parseFloat(p.xError || 0),
                    yError: parseFloat(p.yError || 0)
                }));

                if (validData.length === 0) return;

                datasets.push({
                    label: serie.name,
                    data: validData,
                    backgroundColor: serie.color,
                    borderColor: serie.color,
                    showLine: false,
                    pointRadius: 5,
                    errorBars: true
                });

                if (serie.fitType !== 'none' && validData.length >= 2) {
                    const fit = calculateFit(validData, serie.fitType);
                    serie.equation = fit.equation;
                    serie.r2 = fit.r2;

                    datasets.push({
                        type: 'line',
                        label: `${serie.name} (ajuste)`,
                        data: fit.points,
                        borderColor: serie.color,
                        backgroundColor: 'transparent',
                        showLine: true,
                        pointRadius: 0,
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.4
                    });

                    const eqDiv = document.getElementById(`eq-${serie.id}`);
                    eqDiv.style.display = 'block';
                    eqDiv.innerHTML = `
                        <strong>Ecuaci√≥n:</strong> ${fit.equation}
                        <button class="help-btn" onclick="toggleHelp(${serie.id}, '${serie.fitType}')">?</button>
                        <br><strong>R¬≤ =</strong> ${fit.r2.toFixed(6)}
                        <div class="help-text" id="help-${serie.id}"></div>
                    `;
                } else {
                    const eqDiv = document.getElementById(`eq-${serie.id}`);
                    eqDiv.style.display = 'none';
                }
            });

            chart.data.datasets = datasets;
            chart.update();
        }

        function calculateFit(data, type) {
            const xs = data.map(p => p.x);
            const ys = data.map(p => p.y);
            const n = xs.length;

            let equation = '';
            let r2 = 0;
            let fitFunc = null;
            let uncertainty = null;

            if (type === 'linear') {
                const result = linearRegression(data);
                const a = result.slope;
                const b = result.intercept;

                let eqStr = `y = ${a.toFixed(4)}x + ${b.toFixed(4)}`;
                if (result.uncertainty) {
                    eqStr += `<br><span style="font-size:0.9em; color:#666">
                        m = ${a.toFixed(4)} ¬± ${result.uncertainty.dm.toFixed(4)}<br>
                        b = ${b.toFixed(4)} ¬± ${result.uncertainty.db.toFixed(4)}
                    </span>`;
                }

                equation = eqStr;
                r2 = result.r2;
                fitFunc = x => a * x + b;
                uncertainty = result.uncertainty;
            }
            else if (type === 'poly2') {
                const coeffs = polynomialRegression(xs, ys, 2);
                equation = `y = ${coeffs[0].toFixed(4)}x¬≤ + ${coeffs[1].toFixed(4)}x + ${coeffs[2].toFixed(4)}`;
                r2 = calculateR2(ys, xs.map(x => coeffs[0] * x * x + coeffs[1] * x + coeffs[2]));
                fitFunc = x => coeffs[0] * x * x + coeffs[1] * x + coeffs[2];
            }
            else if (type === 'poly3') {
                const coeffs = polynomialRegression(xs, ys, 3);
                equation = `y = ${coeffs[0].toFixed(4)}x¬≥ + ${coeffs[1].toFixed(4)}x¬≤ + ${coeffs[2].toFixed(4)}x + ${coeffs[3].toFixed(4)}`;
                r2 = calculateR2(ys, xs.map(x => coeffs[0] * x * x * x + coeffs[1] * x * x + coeffs[2] * x + coeffs[3]));
                fitFunc = x => coeffs[0] * x * x * x + coeffs[1] * x * x + coeffs[2] * x + coeffs[3];
            }
            else if (type === 'exponential') {
                const result = exponentialRegression(xs, ys);
                equation = `y = ${result.a.toFixed(4)}e^(${result.b.toFixed(4)}x)`;
                r2 = result.r2;
                fitFunc = x => result.a * Math.exp(result.b * x);
            }
            else if (type === 'logarithmic') {
                const result = logarithmicRegression(xs, ys);
                equation = `y = ${result.a.toFixed(4)}ln(x) + ${result.b.toFixed(4)}`;
                r2 = result.r2;
                fitFunc = x => result.a * Math.log(x) + result.b;
            }
            else if (type === 'power') {
                const result = powerRegression(xs, ys);
                equation = `y = ${result.a.toFixed(4)}x^(${result.b.toFixed(4)})`;
                r2 = result.r2;
                fitFunc = x => result.a * Math.pow(x, result.b);
            }

            let minX = Math.min(...xs);
            const maxX = Math.max(...xs);

            // Adjust minX for logarithmic and power functions if necessary
            if ((type === 'logarithmic' || type === 'power') && minX <= 0) {
                minX = 0.0001; // Avoid 0 or negative values
            }

            const range = maxX - minX;
            const points = [];

            for (let i = 0; i <= 100; i++) {
                const x = minX + (range * i / 100);
                // Ensure x is valid for the function type
                if ((type === 'logarithmic' || type === 'power') && x <= 0) continue;

                points.push({ x: x, y: fitFunc(x) });
            }

            return { equation, r2, points, uncertainty };
        }

        function linearRegression(data) {
            const xs = data.map(p => p.x);
            const ys = data.map(p => p.y);
            const n = xs.length;

            const sumX = xs.reduce((a, b) => a + b, 0);
            const sumY = ys.reduce((a, b) => a + b, 0);
            const sumXY = xs.reduce((sum, x, i) => sum + x * ys[i], 0);
            const sumX2 = xs.reduce((sum, x) => sum + x * x, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            const yPred = xs.map(x => slope * x + intercept);
            const r2 = calculateR2(ys, yPred);

            // Calculate Uncertainty using Max/Min Slope Method
            let uncertainty = null;
            const hasErrors = data.some(p => p.xError > 0 || p.yError > 0);

            if (hasErrors && n >= 2) {
                // Sort by X to find endpoints
                const sortedData = [...data].sort((a, b) => a.x - b.x);
                const p1 = sortedData[0];
                const pn = sortedData[n - 1];

                // Centroid
                const xBar = sumX / n;
                const yBar = sumY / n;

                // Worst case slopes (Endpoint Method)
                // Max Slope: Steepest possible line between error boxes of endpoints
                // Min Slope: Flattest possible line between error boxes of endpoints

                // Case 1: Positive slope
                let mMax, mMin;

                if (slope >= 0) {
                    // Steepest: (x1+dx, y1-dy) to (xn-dx, yn+dy)
                    // Denominator min, Numerator max
                    const x1_inner = p1.x + p1.xError;
                    const y1_inner = p1.y - p1.yError;
                    const xn_inner = pn.x - pn.xError;
                    const yn_inner = pn.y + pn.yError;

                    // Flattest: (x1-dx, y1+dy) to (xn+dx, yn-dy)
                    // Denominator max, Numerator min
                    const x1_outer = p1.x - p1.xError;
                    const y1_outer = p1.y + p1.yError;
                    const xn_outer = pn.x + pn.xError;
                    const yn_outer = pn.y - pn.yError;

                    mMax = (yn_inner - y1_inner) / (xn_inner - x1_inner);
                    mMin = (yn_outer - y1_outer) / (xn_outer - x1_outer);
                } else {
                    // Negative slope logic
                    // Steepest (most negative): (x1+dx, y1+dy) to (xn-dx, yn-dy)
                    const x1_inner = p1.x + p1.xError;
                    const y1_inner = p1.y + p1.yError;
                    const xn_inner = pn.x - pn.xError;
                    const yn_inner = pn.y - pn.yError;

                    // Flattest (least negative): (x1-dx, y1-dy) to (xn+dx, yn+dy)
                    const x1_outer = p1.x - p1.xError;
                    const y1_outer = p1.y - p1.yError;
                    const xn_outer = pn.x + pn.xError;
                    const yn_outer = pn.y + pn.yError;

                    mMax = (yn_inner - y1_inner) / (xn_inner - x1_inner); // Will be more negative
                    mMin = (yn_outer - y1_outer) / (xn_outer - x1_outer); // Will be less negative
                }

                // Ensure mMax is actually the larger value algebraically
                if (mMax < mMin) [mMax, mMin] = [mMin, mMax];

                const dm = (mMax - mMin) / 2;

                // Calculate intercept uncertainty
                // b = yBar - m * xBar
                // db = |xBar| * dm (simplified approximation centered at centroid)
                // Or better: calculate bMax and bMin corresponding to mMax and mMin passing through centroid
                // bMax = yBar - mMin * xBar (if xBar > 0) ... this gets complex.
                // Let's use the range of intercepts from the max/min lines.
                // Line Max: y - yBar = mMax(x - xBar) => b1 = yBar - mMax*xBar
                // Line Min: y - yBar = mMin(x - xBar) => b2 = yBar - mMin*xBar
                const b1 = yBar - mMax * xBar;
                const b2 = yBar - mMin * xBar;
                const db = Math.abs(b1 - b2) / 2;

                uncertainty = { dm, db, mMax, mMin };
            }

            return { slope, intercept, r2, uncertainty };
        }

        function polynomialRegression(xs, ys, degree) {
            const n = xs.length;
            const matrix = [];
            const result = [];

            for (let i = 0; i <= degree; i++) {
                const row = [];
                for (let j = 0; j <= degree; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += Math.pow(xs[k], i + j);
                    }
                    row.push(sum);
                }
                matrix.push(row);

                let sum = 0;
                for (let k = 0; k < n; k++) {
                    sum += ys[k] * Math.pow(xs[k], i);
                }
                result.push(sum);
            }

            return gaussianElimination(matrix, result).reverse();
        }

        function gaussianElimination(matrix, result) {
            const n = matrix.length;

            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {
                        maxRow = k;
                    }
                }

                [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];
                [result[i], result[maxRow]] = [result[maxRow], result[i]];

                for (let k = i + 1; k < n; k++) {
                    const factor = matrix[k][i] / matrix[i][i];
                    result[k] -= factor * result[i];
                    for (let j = i; j < n; j++) {
                        matrix[k][j] -= factor * matrix[i][j];
                    }
                }
            }

            const solution = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                solution[i] = result[i];
                for (let j = i + 1; j < n; j++) {
                    solution[i] -= matrix[i][j] * solution[j];
                }
                solution[i] /= matrix[i][i];
            }

            return solution;
        }

        function exponentialRegression(xs, ys) {
            const lnYs = ys.map(y => Math.log(y));
            const result = linearRegression(xs, lnYs);
            const a = Math.exp(result.intercept);
            const b = result.slope;

            const yPred = xs.map(x => a * Math.exp(b * x));
            const r2 = calculateR2(ys, yPred);

            return { a, b, r2 };
        }

        function logarithmicRegression(xs, ys) {
            const lnXs = xs.map(x => Math.log(x));
            const result = linearRegression(lnXs, ys);
            const a = result.slope;
            const b = result.intercept;

            const yPred = xs.map(x => a * Math.log(x) + b);
            const r2 = calculateR2(ys, yPred);

            return { a, b, r2 };
        }

        function powerRegression(xs, ys) {
            const lnXs = xs.map(x => Math.log(x));
            const lnYs = ys.map(y => Math.log(y));
            const result = linearRegression(lnXs, lnYs);
            const a = Math.exp(result.intercept);
            const b = result.slope;

            const yPred = xs.map(x => a * Math.pow(x, b));
            const r2 = calculateR2(ys, yPred);

            return { a, b, r2 };
        }

        function calculateR2(observed, predicted) {
            const mean = observed.reduce((a, b) => a + b, 0) / observed.length;
            const ssTotal = observed.reduce((sum, y) => sum + Math.pow(y - mean, 2), 0);
            const ssResidual = observed.reduce((sum, y, i) => sum + Math.pow(y - predicted[i], 2), 0);
            return 1 - (ssResidual / ssTotal);
        }

        function toggleHelp(serieId, fitType) {
            const helpDiv = document.getElementById(`help-${serieId}`);

            if (helpDiv.style.display === 'block') {
                helpDiv.style.display = 'none';
                return;
            }

            let helpText = '';

            switch (fitType) {
                case 'linear':
                    helpText = `
                        <strong>Ecuaci√≥n Lineal: y = ax + b</strong><br>
                        ‚Ä¢ <strong>a</strong>: Pendiente de la recta (cu√°nto cambia Y por cada unidad de X)<br>
                        ‚Ä¢ <strong>b</strong>: Ordenada al origen (valor de Y cuando X = 0)<br>
                        ‚Ä¢ <strong>R¬≤</strong>: Coeficiente de determinaci√≥n (0 a 1, m√°s cerca de 1 = mejor ajuste)<br>
                        <br>
                        <strong>Incertidumbre (M√©todo de Pendiente M√°xima/M√≠nima):</strong><br>
                        ‚Ä¢ <strong>m ¬± Œîm</strong>: Pendiente con su error estimado<br>
                        ‚Ä¢ <strong>b ¬± Œîb</strong>: Ordenada con su error estimado<br>
                        <em>Calculado usando las cajas de error de los puntos extremos.</em>
                    `;
                    break;
                case 'poly2':
                    helpText = `
                        <strong>Ecuaci√≥n Polinomial Grado 2: y = ax¬≤ + bx + c</strong><br>
                        ‚Ä¢ <strong>a</strong>: Coeficiente cuadr√°tico (controla la curvatura de la par√°bola)<br>
                        ‚Ä¢ <strong>b</strong>: Coeficiente lineal<br>
                        ‚Ä¢ <strong>c</strong>: T√©rmino independiente (valor de Y cuando X = 0)<br>
                        ‚Ä¢ <strong>R¬≤</strong>: Coeficiente de determinaci√≥n (0 a 1, m√°s cerca de 1 = mejor ajuste)
                    `;
                    break;
                case 'poly3':
                    helpText = `
                        <strong>Ecuaci√≥n Polinomial Grado 3: y = ax¬≥ + bx¬≤ + cx + d</strong><br>
                        ‚Ä¢ <strong>a</strong>: Coeficiente c√∫bico (controla la forma de la curva)<br>
                        ‚Ä¢ <strong>b</strong>: Coeficiente cuadr√°tico<br>
                        ‚Ä¢ <strong>c</strong>: Coeficiente lineal<br>
                        ‚Ä¢ <strong>d</strong>: T√©rmino independiente (valor de Y cuando X = 0)<br>
                        ‚Ä¢ <strong>R¬≤</strong>: Coeficiente de determinaci√≥n (0 a 1, m√°s cerca de 1 = mejor ajuste)
                    `;
                    break;
                case 'exponential':
                    helpText = `
                        <strong>Ecuaci√≥n Exponencial: y = a¬∑e^(bx)</strong><br>
                        ‚Ä¢ <strong>a</strong>: Valor inicial (valor de Y cuando X = 0)<br>
                        ‚Ä¢ <strong>b</strong>: Tasa de crecimiento/decrecimiento exponencial<br>
                        &nbsp;&nbsp;- Si b > 0: crecimiento exponencial<br>
                        &nbsp;&nbsp;- Si b < 0: decrecimiento exponencial<br>
                        ‚Ä¢ <strong>e</strong>: N√∫mero de Euler (‚âà 2.71828)<br>
                        ‚Ä¢ <strong>R¬≤</strong>: Coeficiente de determinaci√≥n (0 a 1, m√°s cerca de 1 = mejor ajuste)
                    `;
                    break;
                case 'logarithmic':
                    helpText = `
                        <strong>Ecuaci√≥n Logar√≠tmica: y = a¬∑ln(x) + b</strong><br>
                        ‚Ä¢ <strong>a</strong>: Factor de escala del logaritmo<br>
                        ‚Ä¢ <strong>b</strong>: Desplazamiento vertical<br>
                        ‚Ä¢ <strong>ln</strong>: Logaritmo natural (base e)<br>
                        ‚Ä¢ <strong>R¬≤</strong>: Coeficiente de determinaci√≥n (0 a 1, m√°s cerca de 1 = mejor ajuste)<br>
                        <em>Nota: Solo funciona con valores X positivos</em>
                    `;
                    break;
                case 'power':
                    helpText = `
                        <strong>Ecuaci√≥n Potencial: y = a¬∑x^b</strong><br>
                        ‚Ä¢ <strong>a</strong>: Coeficiente de escala<br>
                        ‚Ä¢ <strong>b</strong>: Exponente (determina el tipo de relaci√≥n)<br>
                        &nbsp;&nbsp;- Si b > 1: crecimiento acelerado<br>
                        &nbsp;&nbsp;- Si 0 < b < 1: crecimiento desacelerado<br>
                        &nbsp;&nbsp;- Si b < 0: decrecimiento<br>
                        ‚Ä¢ <strong>R¬≤</strong>: Coeficiente de determinaci√≥n (0 a 1, m√°s cerca de 1 = mejor ajuste)<br>
                        <em>Nota: Solo funciona con valores X e Y positivos</em>
                    `;
                    break;
            }

            helpDiv.innerHTML = helpText;
            helpDiv.style.display = 'block';
        }

        function resetZoom() {
            chart.resetZoom();
        }

        function downloadChart() {
            const link = document.createElement('a');
            link.download = 'grafica.png';
            link.href = chart.toBase64Image();
            link.click();
        }

        initChart();
        addSerie();
    </script>
</body>

</html>